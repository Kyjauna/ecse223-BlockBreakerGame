class PlayedGame {

  // State Machine
  
  playStatus {
    Ready {
      entry / { doSetup(); }
      play -> Moving;
    }
    Moving {
      pause -> Paused;
      move [hitPaddle()] / { doHitPaddleOrWall(); } -> Moving;
      move [isOutOfBoundsAndLastLife()] / { doOutOfBounds(); } -> GameOver;
      move [isOutOfBounds()] / { doOutOfBounds(); } -> Paused;
      move [hitLastBlockAndLastLevel()] / { doHitBlock(); } -> GameOver;
      move [hitLastBlock()] / { doHitBlockNextLevel(); } -> Ready;
      move [hitBlock()] / { doHitBlock(); } -> Moving;
      move [hitWall()] / { doHitPaddleOrWall(); } -> Moving;
      move / { doHitNothingAndNotOutOfBounds(); } -> Moving;
    }
    Paused {
      play -> Moving;
    }
    GameOver {
      entry / { doGameOver(); }
    }
  }
  
  // Guards
  
   private boolean hitPaddle(){
	   BouncePoint bp = calculateBouncePointPaddle();
	   setBounce(bp);
	   if (bp != null) {
		   return true;
	   }
	   else 
		   return false;
  }
   
   private BouncePoint calculateBouncePointPaddle(){
    // Current position of the ball
	   double x = getCurrentBallX();
	   double y = getCurrentBallY();
	   // Where the ball is going
	   double dx = getBallDirectionX();
	   double dy = getBallDirectionY();
	   // New position of the ball
	   double positionX = (x+dx);
	   double positionY = (y+dy);
	   
	   BouncePoint bp = null;
	   
	   // Add 5 to all the variables to account for the radius of the ball
	   Rectangle2D regionA = new Rectangle2D.Double(getCurrentPaddleX(), getCurrentPaddleY()-5.0, getCurrentPaddleLength(), 5.0);
	   Rectangle2D regionB = new Rectangle2D.Double(getCurrentPaddleX(), getCurrentPaddleY()-5.0, 5.0, 5.0);
	   Rectangle2D regionC = new Rectangle2D.Double(getCurrentPaddleX()+getCurrentPaddleLength(), getCurrentPaddleY(), 5.0, 5.0);
	   Rectangle2D regionF = new Rectangle2D.Double(getCurrentPaddleX()+getCurrentPaddleLength(), getCurrentPaddleY()-5, 5.0, 5.0);
	   Rectangle2D regionE = new Rectangle2D.Double(getCurrentPaddleX()-5, getCurrentPaddleY()-5, 5.0, 5.0);
	   
	   
	   
	   java.awt.geom.Ellipse2D ball= new java.awt.geom.Ellipse2D.Double(positionX-5, positionY-5, 10, 10);
	   
		   // BOUNCE
		  
	   
	   // Section A
		   if (ball.intersects(regionA)) {
			   bp = new BouncePoint(0,0,null);
			   bp.setX(positionX);
			   bp.setY(positionY);
			   bp.setDirection(BouncePoint.BounceDirection.FLIP_Y);
		   }
		   
		   // Section B
		   if (ball.intersects(regionB)||ball.intersects(regionC)) {
			   bp = new BouncePoint(0,0,null);
			   bp.setX(positionX);
			   bp.setY(positionY);
			   bp.setDirection(BouncePoint.BounceDirection.FLIP_X);
		   }
		   
//		   // Section C
//		   if (positionX == (getCurrentPaddleX()+getCurrentPaddleLength()+5) && positionY >= 355 && positionY <= 360) {
//			   bp = new BouncePoint(0,0,null);
//			   bp.setX(positionX);
//			   bp.setY(positionY);
//			   bp.setDirection(BouncePoint.BounceDirection.FLIP_X);
//		   }
		   
		   // Section E
		   // Incomplete; does not account for the whole curvature; only for the corner
		   if (ball.intersects(regionE)) {
			   bp = new BouncePoint(0,0,null);
			   bp.setX(positionX);
			   bp.setY(positionY);
			   bp.setDirection(BouncePoint.BounceDirection.FLIP_BOTH);
		   }
		   
		   // Section F
		   if (ball.intersects(regionF)) {
			   bp = new BouncePoint(0,0,null);
			   bp.setX(positionX);
			   bp.setY(positionY);
			   bp.setDirection(BouncePoint.BounceDirection.FLIP_BOTH);
		   }
	  // }
	   return bp;
  }
   
   private void bounceBall(){
		double incomingX;
		double remainingX;
		double incomingY;
		double remainingY;
		double currentx=getCurrentBallX();
		double currenty=getCurrentBallY();
		double bpx=bounce.getX();
		double bpy=bounce.getY();
		double dx=getBallDirectionX();
		double dy=getBallDirectionY();

		System.out.println("dy= "+getBallDirectionY());
		System.out.println("dx= "+getBallDirectionX());
		System.out.println("currentx=" +getCurrentBallX());
		System.out.println("currenty= "+getCurrentBallY());
		System.out.println("bpy= "+bounce.getY());
		System.out.println("bpx= "+bounce.getX());


		System.out.println(bounce);

		// Flip_X case
		if (bounce.getDirection() == BouncePoint.BounceDirection.FLIP_X) {
			// Incoming distance
			incomingX = (bpx - currentx); System.out.println("incomingX: "+incomingX);
			remainingX = dx - incomingX; System.out.println("remainingX: "+remainingX);
			if (remainingX == 0) {
				setCurrentBallX(bounce.getX());
				setCurrentBallY(bounce.getY());

				if (bounce.getHitBlock()!=null) {
					double sign=Math.signum(dy);
					if (sign==0) {sign=1;}
					setBallDirectionX(dx*(-1));
					setBallDirectionY(dy + sign*0.1*Math.abs(dx));
				}
			}
			else
			{
				double sign=Math.signum(dy);
				if (sign==0) {sign=1;}
				setBallDirectionX(dx*(-1));
				setBallDirectionY(dy + sign*0.1*Math.abs(dx));

				setCurrentBallX(bounce.getX() + (remainingX/dx)*(getBallDirectionX()));
				setCurrentBallY(bounce.getY() + (remainingX/dx)*(getBallDirectionY()));
			}
		}

		// Flip_Y case
		if (bounce.getDirection() == BouncePoint.BounceDirection.FLIP_Y) {
			// Incoming distance
			incomingY = (bpy - currenty);
			remainingY = dy - incomingY;

			System.out.println("incomingY: "+incomingY);
			System.out.println("remainingX: "+remainingY);

			if (remainingY == 0) {
				setCurrentBallX(bounce.getX());
				setCurrentBallY(bounce.getY());

				if(bounce.getHitBlock()!=null) {
					double sign=Math.signum(dx);
					if (sign==0) {sign=1;}
					setBallDirectionY(dy*(-1));
					setBallDirectionX(dx+Math.signum(dx)*0.1*Math.abs(dy));
				}

			}
			else
			{
				double sign=Math.signum(dx);
				if (sign==0) {sign=1;}

				setBallDirectionY(dy*(-1));
				setBallDirectionX(dx+Math.signum(dx)*0.1*Math.abs(getBallDirectionY()));
				setCurrentBallX(bounce.getX() + (remainingY/dy)*(getBallDirectionX()));
				setCurrentBallY(bounce.getY() + (remainingY/dy)*(getBallDirectionY()));
			} 
		}
		bounce=null; 
	}


   private boolean isOutOfBoundsAndLastLife(){
	   boolean outOfBounds = false;
	   if(lives == 1)
		   outOfBounds = isBallOutOfBounds();
	   return outOfBounds;
  }
  
  private boolean isBallOutOfBounds() {
	   if (getCurrentBallY() > 385)
		   return true;
	   else return false;
  }
  
  private boolean isOutOfBounds() {
	   boolean outOfBounds = isBallOutOfBounds();
	   return outOfBounds;
  }
  
   private boolean hitLastBlockAndLastLevel(){
	   
		 Game game = getGame();
		 int nrLevels = game.numberOfLevels();
		 setBounce(null);
		 
		 if(nrLevels == currentLevel) {
			 int nrBlocks = numberOfBlocks();
			 
			 if(nrBlocks == 1) {
				 
				 PlayedBlockAssignment block = getBlock(0);
				 BouncePoint bp = calculateBouncePointBlock(block);
				 setBounce(bp);
				 return (bp!=null);
			 }
		 }
	    return false;
	  }
  
	private boolean hitLastBlock(){

	   int nrBlocks = numberOfBlocks();
	   setBounce(null);
	   if(nrBlocks == 1) {
		   PlayedBlockAssignment block = getBlock(0);
		   BouncePoint bp = calculateBouncePointBlock(block);
		   this.setBounce(bp);
		   return (bp != null);
	   }
	   return false;
 	}
  
private boolean hitBlock(){
    int nrBlocks = this.numberOfBlocks();
    setBounce(null);
    
    for(int i=0; i<nrBlocks-1; i++) {	
    	PlayedBlockAssignment block = getBlock(i);
    	BouncePoint bp = calculateBouncePointBlock(block);
    	System.out.println(i);
    	System.out.println(bp);
    	//this.setBounce(bp);
    	BouncePoint bounce = this.getBounce();
    	boolean closer = isCloser(bp, bounce);
    	System.out.println(closer);
    	if(closer) {
    		this.setBounce(bp);
    	}
    }
    System.out.println(getBounce()!=null);
    return getBounce()!=null;
  }
  
   private boolean hitWall(){
    BouncePoint bp = calculateBouncePointWall();
	   setBounce(bp);
	   if (bp != null) {
		   return true;
	   }
	   else
		   return false;
  }
  
      private BouncePoint calculateBouncePointWall(){
    // Current position of the ball
	   double x = getCurrentBallX();
	   double y = getCurrentBallY();
	   // Where the ball is going
	   double dx = getBallDirectionX();
	   double dy = getBallDirectionY();
	   // New position of the ball
	   double positionX = (x+dx);
	   double positionY = (y+dy);
	   
	   BouncePoint bp = null;
	   java.awt.geom.Rectangle2D regionA=new java.awt.geom.Rectangle2D.Double(0, 0, 5, 390-5);
	   
	   java.awt.geom.Rectangle2D regionC=new java.awt.geom.Rectangle2D.Double(390-5, 0, 5, 390-5);
	   
	   java.awt.geom.Rectangle2D regionD=new java.awt.geom.Rectangle2D.Double(0, 0, 390-10, 5);
	   
	   java.awt.geom.Ellipse2D ball= new java.awt.geom.Ellipse2D.Double(positionX-5, positionY-5, 10, 10);
	   
	   // Section A
	   if (ball.intersects(regionA)||ball.intersects(regionC)) {
		   bp = new BouncePoint(0,0,null);
		   bp.setX(positionX);
		   bp.setY(positionY);
		   bp.setDirection(BouncePoint.BounceDirection.FLIP_X);
	   }
	   
	   // Section B
	   if (ball.intersects(regionD)) {
		   bp = new BouncePoint(0,0,null);
		   bp.setX(positionX);
		   bp.setY(positionY);
		   bp.setDirection(BouncePoint.BounceDirection.FLIP_Y);
	   }
	   
	   // A-B Corner
	   if (positionX == 5 && positionY == 5) {
		   bp = new BouncePoint(0,0,null);
		   bp.setX(positionX);
		   bp.setY(positionY);
		   bp.setDirection(BouncePoint.BounceDirection.FLIP_BOTH);
	   }
	   
	   // B-C Corner
	   if (positionX == 385 && positionY == 5) {
		   bp = new BouncePoint(0,0,null);
		   bp.setX(positionX);
		   bp.setY(positionY);
		   bp.setDirection(BouncePoint.BounceDirection.FLIP_BOTH);
	   }
	   
	   return bp;
  }

  private BouncePoint calculateBouncePointBlock(PlayedBlockAssignment pblock){
    // Current position of the ball
		   double x = getCurrentBallX();
		   double y = getCurrentBallY();
		   // Where the ball is going
		   double dx = getBallDirectionX();
		   double dy = getBallDirectionY();
		   // New position of the ball
		   double positionX = (x+dx);
		   double positionY = (y+dy);
		   
		   BouncePoint bp = null; 
		   //java.awt.geom.Rectangle2D physicalblock=new java.awt.geom.Rectangle2D.Double(pblock.getX()-10, pblock.getY()-10, 30.0, 30.0);
		   
		   java.awt.geom.Rectangle2D regionA=new java.awt.geom.Rectangle2D.Double(pblock.getX(), pblock.getY()-5, 20, 5);
		   
		   java.awt.geom.Rectangle2D regionD=new java.awt.geom.Rectangle2D.Double(pblock.getX(), pblock.getY()+20, 20, 5);
		   
		   java.awt.geom.Rectangle2D regionB=new java.awt.geom.Rectangle2D.Double(pblock.getX()-5, pblock.getY(), 5, 20);
		   
		   java.awt.geom.Rectangle2D regionC=new java.awt.geom.Rectangle2D.Double(pblock.getX()+20, pblock.getY(), 5, 20);
		   
		   java.awt.geom.Rectangle2D regionE=new java.awt.geom.Rectangle2D.Double(pblock.getX()-5, pblock.getY()-5, 5, 5);
		   
		   java.awt.geom.Rectangle2D regionF=new java.awt.geom.Rectangle2D.Double(pblock.getX()+20, pblock.getY()-5, 5, 5);
		   
		   java.awt.geom.Rectangle2D regionG=new java.awt.geom.Rectangle2D.Double(pblock.getX()-5, pblock.getY()+20, 5, 5);
		   
		   java.awt.geom.Rectangle2D regionH=new java.awt.geom.Rectangle2D.Double(pblock.getX()+20, pblock.getY()+20, 5, 5);
		   
		   java.awt.geom.Ellipse2D ball=new java.awt.geom.Ellipse2D.Double(positionX-5, positionY-5, 10, 10);
		   
		   
				
				// Section A and D
				   if (ball.intersects(regionA)||ball.intersects(regionD)) {
					   bp = new BouncePoint(0,0,null);
					   bp.setHitBlock(pblock);
					   bp.setX(positionX);
					   bp.setY(positionY);
					   bp.setDirection(BouncePoint.BounceDirection.FLIP_X);
				   }
				   
				   // Section B and C
				   if (ball.intersects(regionB)||ball.intersects(regionC)) {
					   bp = new BouncePoint(0,0,null);
					   bp.setHitBlock(pblock);
					   bp.setX(positionX);
					   bp.setY(positionY);
					   bp.setDirection(BouncePoint.BounceDirection.FLIP_Y);
				   }
					
					 //Section E and G
				   if (ball.intersects(regionE)||ball.intersects(regionG)) {
						   bp = new BouncePoint(0,0,null);
						   bp.setHitBlock(pblock);
						   bp.setX(positionX);
						   bp.setY(positionY);
						   bp.setDirection(BouncePoint.BounceDirection.FLIP_BOTH);
						   //flip Y if ball approaches from right and Flip X if ball approaches from left
				   }
						   
					   //Section F and H
				   if (ball.intersects(regionF)||ball.intersects(regionH)) {
					   bp = new BouncePoint(0,0,null);
					   bp.setHitBlock(pblock);
					   bp.setX(positionX);
					   bp.setY(positionY);
					   bp.setDirection(BouncePoint.BounceDirection.FLIP_BOTH);
					   //Flip X of ball approaches from right and Flip Y if ball approaches from left
					}   
		
		   return bp;
  }
  // Actions
  
   private void doSetup(){
    Random rgen=new Random();
	   	doReset();
	    Game game=getGame();
	    Level level = game.getLevel(currentLevel-1);
	    List<BlockAssignment> assignments= level.getBlockAssignments();
	    
	    for (BlockAssignment a: assignments){
	    	PlayedBlockAssignment pblock=new PlayedBlockAssignment(Game.WALL_PADDING+(Block.SIZE+Game.COLUMNS_PADDING)*(a.getGridHorizontalPosition()-1),
	    			Game.WALL_PADDING+(Block.SIZE+Game.ROW_PADDING)*(a.getGridVerticalPosition()-1), a.getBlock(), this);
	    }
	    
	    while (numberOfBlocks()<game.getNrBlocksPerLevel()) {
	   		int x=rgen.nextInt(15)+1;
			int y=rgen.nextInt(10)+1;
			while (level.findBlockAssignment(x,y)!=null) {
				x++;
				if (x==15) {
					y++;
					x=1;
				}
			}
	    	PlayedBlockAssignment pblock=new PlayedBlockAssignment(Game.WALL_PADDING+(Block.SIZE+Game.COLUMNS_PADDING)*(x-1),
	    			Game.WALL_PADDING+(Block.SIZE+Game.ROW_PADDING)*(y-1), game.getRandomBlock(), this);
	    
	    }
  }
  
  private void doReset(){
  	resetCurrentBallX();
  	resetCurrentBallY();
  	resetBallDirectionX();
  	resetBallDirectionY();
  	resetCurrentPaddleX();
  }
  
  private void doHitPaddleOrWall() {
	   bounceBall();
	   
  }

   private void doOutOfBounds(){
	   setLives(lives-1);
	   doReset();
  }
  
   private void doHitBlock(){
    score = getScore();   
		bounce = getBounce();
		if(bounce!=null) {
			System.out.println(bounce);
			System.out.println(bounce.getHitBlock());
			PlayedBlockAssignment pblock = bounce.getHitBlock();
			Block block = pblock.getBlock();
			int points = block.getPoints();
			setScore(score+points);
			pblock.delete();
			bounceBall();
		}
  }

	private void doHitBlockNextLevel(){
    	doHitBlock();
    	int level = this.getCurrentLevel();
    
    	setCurrentLevel(level+1);
    	setCurrentPaddleLength(getGame().getPaddle().getMaxPaddleLength()-(getGame().getPaddle().getMaxPaddleLength()-getGame().getPaddle().getMinPaddleLength())/(getGame().numberOfLevels()-1)*(getCurrentLevel()-1));
    	setWaitTime(INITIAL_WAIT_TIME*(int)getGame().getBall().getBallSpeedIncreaseFactor()^(getCurrentLevel()-1));
  	}

	private void doHitNothingAndNotOutOfBounds(){
	   
	   double x = getCurrentBallX();
	   double y = getCurrentBallY();
	   
	   double dx = getBallDirectionX();
	   double dy = getBallDirectionY();
	   
	   setCurrentBallX(x+dx);
	   setCurrentBallY(y+dy);
	   
  	}

	private void doGameOver() {
    	Block223 block223=this.getBlock223();
    	Player p=this.getPlayer();
    	
    	if (p!=null){
    		Game game=this.getGame();
    		HallOfFameEntry hof=new HallOfFameEntry(score, playername, p, game, block223);
    		game.setMostRecentEntry(hof);
    		//this.delete();
    	}
  	}

}
